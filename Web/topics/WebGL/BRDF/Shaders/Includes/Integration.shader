////////////////////////////////////////////////////////////////
// BRDF Monte Carlo Integration include file
//
#ifndef _INTEGRATION_INCLUDED_
#define _INTEGRATION_INCLUDED_

uniform vec3		_dUV;				// 1/ViewportSize
uniform int			_PassIndex;			// Pass index used for random generation
uniform int			_Random0;
uniform int			_Random1;
uniform sampler2D	_TexPreviousImage;	// Previous pass rendering for accumulation
uniform float		_ConvergenceRate;	// Convergence rate of the Monte Carlo integration

uniform float		_NormalStrength;
uniform sampler2D	_TexNormalMap;		// Optional normal map


// Small test with anisotropy
uniform vec3		_Anisotropy;
void	Anisotropize( inout vec3 _DirectionTS, vec3 _Anisotropy )
{
//	vec2	Temp = vec2( _Anisotropy.x * _DirectionTS.x, _DirectionTS.y / _Anisotropy.x );
	vec2	Temp = vec2( _Anisotropy.x * _DirectionTS.x, _DirectionTS.y );

	_DirectionTS.x = _Anisotropy.y * Temp.x + _Anisotropy.z * Temp.y;
	_DirectionTS.y = -_Anisotropy.z * Temp.x + _Anisotropy.y * Temp.y;

//	_DirectionTS = normalize( _DirectionTS );
}


// Different light models
#include "LightModels.shader"


// Code from the Disney BRDF explorer
// NOTE: DOESN'T WORK => No support for uints & binary operators in webgl FFS!
//
// uint	Hash( uint x, uint y )
// {
//     const uint M = 1664525u, C = 1013904223u;
//     uint seed = (x * M + y + C) * M;
//     // tempering (from Matsumoto)
//     seed ^= (seed >> 11u);
//     seed ^= (seed << 7u) & 0x9d2c5680u;
//     seed ^= (seed << 15u) & 0xefc60000u;
//     seed ^= (seed >> 18u);
//     return seed;
// }
// 
// 
// float	HammersleySample( uint bits, uint seed )
// {
//     bits = ( bits << 16u) | ( bits >> 16u);
//     bits = ((bits & 0x00ff00ffu) << 8u) | ((bits & 0xff00ff00u) >> 8u);
//     bits = ((bits & 0x0f0f0f0fu) << 4u) | ((bits & 0xf0f0f0f0u) >> 4u);
//     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xccccccccu) >> 2u);
//     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xaaaaaaaau) >> 1u);
//     bits ^= seed;
//     return float(bits) * 2.3283064365386963e-10; // divide by 1<<32
// }

vec4	Random( int _Random0, int _Random1 )
{
	vec4	R0 = vec4( _Random0 + _Random1, 2 * (_Random0 + _Random1), _Random1, 2 * _Random1 );

	// Nothing special here, just numbers generated by bashing keyboard
	vec4 s1 = sin( R0 * 3.3422 + gl_FragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234) ) * 543.3423;
	vec4 s2 = sin( R0 * 1.3422 + gl_FragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234) ) * 654.5423;
	return fract( vec4(2142.4) + s1 + s2 );
}

// For this function to work you MUST define the GetLightInfos() function first
vec3	SampleEnvLight( vec2 _RandomUV, vec3 _ViewTS, vec3 _Position, vec3 _Tangent, vec3 _BiTangent, vec3 _Normal )
{
	// Retrieve Li * (L.N) * dw
	vec3	LightRadiance, LightTS;
	GetLightRadiance( _RandomUV, _Position, _Tangent, _BiTangent, _Normal, LightRadiance, LightTS );

	// Test!
	Anisotropize( LightTS, _Anisotropy );
//	Anisotropize( _ViewTS, vec3( _Anisotropy.x, -_Anisotropy.z, _Anisotropy.y ) );

//LightTS = vec3( 0, 0, 1 );	// Normal to the surface

	// Get reflectance in that direction
	vec3	Reflectance = BRDF( LightTS, _ViewTS, _ShowLogLuma );
//return _LightIntensity * Reflectance;

	// Lo = BRDF * Li * (L.N) . dw
	return Reflectance * LightRadiance;
}

vec3	AccumulateRadiance( vec3 _ViewTS, vec3 _Position, vec3 _Tangent, vec3 _BiTangent, vec3 _Normal )
{
    const float	fNormalizer = 1.0 / float(MC_SAMPLES_COUNT);

// 	uint	Seed1 = Hash( uint(gl_FragCoord.x), uint(gl_FragCoord.y) );
// 	uint	Seed2 = Hash( Seed1, 1000u );
//	float	u = float(Seed1) * 2.3283064365386963e-10;

//return SampleEnvLight( vec2( 0.0 ), _ViewTS, _Position, _Tangent, _BiTangent, _Normal );

	vec3	Result = vec3( 0 );
	for( int i=0; i < MC_SAMPLES_COUNT; i++ )
	{

// No support for Hammersley in WebGL!
// 		vec2	UV = vec2(	fract( u + i * fNormalizer ),
// 							fract( HammersleySample( i, Seed2 ) )
// 						 );

		vec2	UV = Random( _Random0 + i, _Random1 ).xy;

		// Choose a sample from the environment map
		Result += SampleEnvLight( UV, _ViewTS, _Position, _Tangent, _BiTangent, _Normal );
	}

	return fNormalizer * Result;
}

vec3	IntegrateBRDF( vec2 _UV, vec3 _View, vec3 _Position, vec3 _Tangent, vec3 _BiTangent, vec3 _Normal )
{
	if ( !_BRDFValid )
		return vec3( saturate( dot( _Normal, normalize( vec3( 1 ) ) ) ) );

	// Rotate tangent space with new normal
	{

// Remap planar into pipo spherical
vec3	Pipo = normalize( _Position );
_UV = vec2( 1.0 + atan( Pipo.x, Pipo.z ) * INV_PI, acos( Pipo.y ) * INV_PI );

		vec3	NormalTS = SampleNormalMap( _TexNormalMap, _UV, _NormalStrength );
		RotateTangentSpace( _Tangent, _BiTangent, _Normal, NormalTS );
	}

	vec3	ViewTS = vec3( dot( _View, _Tangent ), dot( _View, _BiTangent ), dot( _View, _Normal ) );

	vec3	PreviousRadiance = vec3( 0.0 );
	if ( _PassIndex > 0 )
	{
		vec2	ScreenUVs = gl_FragCoord.xy * _dUV.xy;
		PreviousRadiance = texture2D( _TexPreviousImage, ScreenUVs ).xyz;
	}

	vec3	Radiance = AccumulateRadiance( ViewTS, _Position, _Tangent, _BiTangent, _Normal );

	vec3	ConvergedRadiance = lerp( PreviousRadiance, Radiance, _ConvergenceRate );

	return ConvergedRadiance;
}

#endif	//  _INTEGRATION_INCLUDED_
