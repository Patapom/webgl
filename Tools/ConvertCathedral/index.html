<!DOCTYPE html>
<!-- Loads a scene using my proprietary format -->
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>
WebGL Scene Objects
</title>

<script type="text/javascript" src="../../Web/o3djs/base.js"></script>	<!-- Include a small part of the O3D library -->
<script type="text/javascript" src="../../Web/patapi/base.js"></script>	<!-- Include PatAPI -->
<script type="text/javascript" src="SourceData/O3Dscene.json"></script>	<!-- Include original JSON -->
<script type="text/javascript" src="PrimitiveDescriptors.js"></script>	<!-- Include primitive descriptors generated by C# -->
<script type="text/javascript">
o3djs.require( 'patapi' );
o3djs.require( 'patapi.math' );


var	g_BUILD_ORIGINAL_BINARY_RANGES = false;	// Define this to build the index/vertex buffers binary ranges for the C# converter
											// If not defined then we use what the C# has generated from these original binary ranges


function	Init()
{
	var	ROOT = g_JSON.objects;
	var	Result = {};


	// Hardcoded shaders
	Result.Shaders = [
		{	ID : 0,
			Name : "SH",
			VSFile : "Shaders/GlobalIllumSH.vs",
			PSFile : "Shaders/GlobalIllumSH.ps",
		},
		{	ID : 1,
			Name : "Emissive",
			VSFile : "Shaders/Emissive.vs",
			PSFile : "Shaders/Emissive.ps",
		},
	];


	var	TextureMap = ConvertTextures( Result, ROOT );
//	var	SamplersMap = ConvertSamplers( ROOT, TextureMap );
	var	MaterialMap = ConvertMaterials( Result, ROOT, TextureMap );
	var PrimitiveMap = ConvertPrimitives( Result, ROOT, MaterialMap );
	var ObjectsMap = ConvertObjects( Result, ROOT, PrimitiveMap );
	ConvertTransforms( Result, ROOT, ObjectsMap );	// Assign transforms

	var	FinalString = JSON.stringify( Result, null, '\t' );

	var	Div = document.getElementById( "ResultJSON" );
	Div.innerText = FinalString;
}

function ConvertPrimitives( _Result, _ROOT, _MaterialMap )
{
	_Result.Primitives = [];

	var	OriginalIDs = {
		Index2ID : [],
		ID2Index : {}
	};

	var	IndexBufferID2Range = ConvertIndexBuffers( _ROOT );
	var	VertexBufferID2Range = ConvertVertexBuffers( _ROOT );
	var	StreamBankID2StreamBank = ConvertStreamBanks( _ROOT, VertexBufferID2Range );

// StreamBank semantics
//POSITION, NORMAL,TANGENT, BINORMAL,COLOR, TEXCOORD

	
	var	SourceBinaryRefIB = [];
	var	SourceBinaryRefVB = [];


	var	Source = _ROOT["o3d.Primitive"];
	var	Target = _Result.Primitives;
    for ( var i=0; i < Source.length; i++ )
	{
		var SourcePrim = Source[i];

		// Retrieve actual material ID
		var	MatID = -1;
		if ( !SourcePrim.params["o3d.material"] )
			continue;	// No material for that one, we don't want it !
		MatID = _MaterialMap.ID2Index[SourcePrim.params["o3d.material"].value.ref];
		if ( MatID == -1 )
			throw "Failed to retrieve material for that primitive !";


		if ( SourcePrim.properties.primitiveType != 4 )
			throw "Primitive is not a triangle list  !";
		if ( SourcePrim.properties.startIndex != 0 )
			throw "StartIndex not 0 !";


		var	Obj =
		{
			ID : Target.length,
//			Name : SourcePrim.properties.name,	// Too many, let's not bother !
			MatID : MatID,
			Topology : "TRIANGLES",

			BlobFile :
			{
				File : "Primitives/Blob" + Target.length + ".bin",
				IndexStreamOffset : -1,
				VertexStreams : [],
			},
// 			IndexStreamFile : "Primitives/CubeIndex.bin",
// 			VertexStreams : 
// 			[
// 				{ Name : "_vPosition", File : "Primitives/Pos" + Target.length + ".bin" },	// Basic naming scheme !
// 				{ Name : "_vUV", File : "Primitives/UV" + Target.length + ".bin" },
// 				{ Name : "_vSH", File : "Primitives/SH" + Target.length + ".bin" },
// 			],
		};


		//////////////////////////////////////////////////////////////////////////
		// Gather binary ranges to store for C# to generate new primitive blobs
		if ( !!g_BUILD_ORIGINAL_BINARY_RANGES )
		{
			// Rebuild the index buffer
			var	IBRange = IndexBufferID2Range[SourcePrim.properties.indexBuffer.ref];
			if ( !IBRange )
				throw "IB not found !";

			IBRange.primitivesCount = SourcePrim.properties.numberPrimitives;
			IBRange.verticesCount = SourcePrim.properties.numberVertices;
			SourceBinaryRefIB[Obj.ID] = IBRange;


			// Rebuild the vertex buffer
			var	StreamBank = StreamBankID2StreamBank[SourcePrim.params["o3d.streamBank"].value.ref];
			if ( !StreamBank )
				throw "StreamBank not found !";

			SourceBinaryRefVB[Obj.ID] = StreamBank;
		}
		//////////////////////////////////////////////////////////////////////////
		// Use new binary ranges generated by C# from its new primitive blobs
		else
		{
			var	ConvertedPrimitive = g_PrimDescriptors[Obj.ID];
			Obj.BlobFile.IndexStreamOffset = ConvertedPrimitive.IndexOffset;
			Obj.BlobFile.VertexStreams = ConvertedPrimitive.VertexStreams;
		}

		// Register
		Target[Obj.ID] = Obj;


		OriginalIDs.Index2ID[Obj.ID] = SourcePrim.id;
		OriginalIDs.ID2Index[SourcePrim.id] = Obj.ID;
	}


	if ( !!g_BUILD_ORIGINAL_BINARY_RANGES )
	{
		// Build the string of IB binary refs for C#
	//	var	SourceBinaryRefIB_asString = JSON.stringify( SourceBinaryRefIB, null, '\t' );
		var	SourceBinaryRefIB_asString = "";
		for ( var i=0; i < SourceBinaryRefIB.length; i++ )
		{
			var IB = SourceBinaryRefIB[i];
			SourceBinaryRefIB_asString += "new IB() { Start = " + IB.Start + ", End = " + IB.End + ", Primitives = " + IB.primitivesCount + ", Vertices = " + IB.verticesCount + " },\n";
		}


		// Build the string of VB binary refs for C#
		var	SourceBinaryRefVB_asString = "";
		for ( var i=0; i < SourceBinaryRefVB.length; i++ )
		{
			var StreamBank = SourceBinaryRefVB[i];
			SourceBinaryRefVB_asString += "new VB() { Streams = new VertexStream[] {\n";
			for ( var j=0; j < StreamBank.custom.vertexStreams.length; j++ )
			{
				var	Stream = StreamBank.custom.vertexStreams[j].stream;
				SourceBinaryRefVB_asString += "	new VertexStream() { Start = " + Stream.binaryRange.Start + ", End = " + Stream.binaryRange.End + ", Semantic = " + Stream.semantic + ", Index = " + Stream.semanticIndex + " },\n";
				if ( Stream.startIndex != 0 )
					throw "Stream start index not 0 !";
			}
			SourceBinaryRefVB_asString += " } },\n";
		}
	}

	return OriginalIDs;
}

function z( a )
{
	return Math.abs( a ) < 1e-6 ? 0 : a;
}

function ConvertTransforms( _Result, _ROOT, _ObjectsMap )
{
	var	Source = _ROOT["o3d.Transform"];
    for ( var i=0; i < Source.length; i++ )
	{
		var SourceTransform = Source[i];
		if ( !SourceTransform.params["o3d.visible"] )
			continue;

		if ( SourceTransform.properties.parent.ref != 1 )
			throw "Not ROOT !";

		var	Matrix = SourceTransform.params["o3d.localMatrix"].value;
// 		if ( !Equal( Matrix[0][0], 1.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[0][1], 0.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[0][2], 0.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[0][3], 0.0 ) ) throw "A!"
// 
// 		if ( !Equal( Matrix[1][0], 0.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[1][1], 0.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[1][2], -1.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[1][3], 0.0 ) ) throw "A!"
// 
// 		if ( !Equal( Matrix[2][0], 0.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[2][1], 1.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[2][2], 0.0 ) ) throw "A!"
// 		if ( !Equal( Matrix[2][3], 0.0 ) ) throw "A!"
// TODO: Handle various orientations !

//		var	Position = [ Matrix[3][0], Matrix[3][1], -Matrix[3][2] ];	// MAX -> Standard

		var	NewMatrix = [
			z( Matrix[0][0] ), z( Matrix[0][1] ), z( Matrix[0][2] ), z( Matrix[0][3] ),
			z( Matrix[1][0] ), z( Matrix[1][1] ), z( Matrix[1][2] ), z( Matrix[1][3] ),
			z( Matrix[2][0] ), z( Matrix[2][1] ), z( Matrix[2][2] ), z( Matrix[2][3] ),
			z( Matrix[3][0] ), z( Matrix[3][1] ), z( Matrix[3][2] ), z( Matrix[3][3] ),
		 ];

		var	Shapes = SourceTransform.properties.shapes;
		for ( var ShapeIndex=0; ShapeIndex < Shapes.length; ShapeIndex++ )
		{
			var	ShapeID = Shapes[ShapeIndex].ref;
			var	ObjectID = _ObjectsMap.ID2Index[ShapeID];
			if ( typeof ObjectID === "undefined" )
				continue;	// Not a registered object...

			var	Obj = _Result.Objects[ObjectID];
//			Obj.Position = Position;	// Reaaally easy ! :)
			Obj.Transform = NewMatrix;	// Reaaally easy ! :)
		}
	}
}

function Equal( a, b )
{
	return Math.abs(a - b) < 1e-6;
}

function ConvertObjects( _Result, _ROOT, _PrimitiveMap )
{
	_Result.Objects = [];

	var	OriginalIDs = {
		Index2ID : [],
		ID2Index : {}
	};

	var	Source = _ROOT["o3d.Shape"];
	var	Target = _Result.Objects;
    for ( var i=0; i < Source.length; i++ )
	{
		var SourceShape = Source[i];

		var	Obj =
		{
			ID : Target.length,
			Name : SourceShape.properties.name,	// Too many, let's not bother !
			Primitives : [],
// 			Transform : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],	// Default if no Transform is identity
// 			Children : [],													// Default is no children
		}

		// Retrieve actual primitive ID
		var	Elements = SourceShape.properties.elements;
		if ( Elements.length == 0 )
			throw "Empty shape ?!";

		var	InvalidPrimitives = false;
		for ( var ElementIndex=0; ElementIndex < Elements.length; ElementIndex++ )
		{
			var	ElementID = Elements[ElementIndex].ref;
			var	PrimitiveID = _PrimitiveMap.ID2Index[ElementID];
			if ( typeof PrimitiveID == "undefined" )
			{	// Must be an object referencing some primitives we rejected
//				throw "WTF?";
				InvalidPrimitives = true;
				break;
			}

			Obj.Primitives.push( PrimitiveID );
		}
		if ( InvalidPrimitives )
			continue;	// This shape contains invalid primitives

		// Register
		Target[Obj.ID] = Obj;


		OriginalIDs.Index2ID[Obj.ID] = SourceShape.id;
		OriginalIDs.ID2Index[SourceShape.id] = Obj.ID;
	}

	return OriginalIDs;
}

function ConvertIndexBuffers( _ROOT )
{
	var	Result = {};
	var	Source = _ROOT["o3d.IndexBuffer"];
	for ( var IBIndex=0; IBIndex < Source.length; IBIndex++ )
	{
		var	IB = Source[IBIndex];
		Result[IB.id] = 
		{
			Start : IB.custom.binaryRange[0],
			End : IB.custom.binaryRange[1],
		};
	}

	return Result;
}

function ConvertVertexBuffers( _ROOT )
{
	var	Result = {};
	var	Source = _ROOT["o3d.VertexBuffer"];
	for ( var VBIndex=0; VBIndex < Source.length; VBIndex++ )
	{
		var	VB = Source[VBIndex];

		if ( VB.custom.fields.length != 1 )
			throw "More than one field in vertex buffer ?!";

		var	FieldIndex = VB.custom.fields[0];

		Result[FieldIndex] = 
		{
			Start : VB.custom.binaryRange[0],
			End : VB.custom.binaryRange[1],
		};
	}

	return Result;
}

function ConvertStreamBanks( _ROOT, _VBID2Range )
{
	var	Result = {};
	var	Source = _ROOT["o3d.StreamBank"];
	for ( var BankIndex=0; BankIndex < Source.length; BankIndex++ )
	{
		var	SourceBank = Source[BankIndex];
		Result[SourceBank.id] = SourceBank

		// Map VB
		for ( var i=0; i < SourceBank.custom.vertexStreams.length; i++ )
		{
			var	Stream = SourceBank.custom.vertexStreams[i].stream;

			if ( typeof _VBID2Range[Stream.field] === "undefined" )
				throw "VB not matched !"
			Stream.binaryRange = _VBID2Range[Stream.field];
		}
	}

	return Result;
}

function ConvertMaterials( _Result, _ROOT, _TextureMap )
{
	_Result.Materials = [];

	var	OriginalIDs = {
		Index2ID : [],
		ID2Index : {}
	};

	var	DummyNormalID = _TextureMap.Sampler2Index[-2]

	var	Source = _ROOT["o3d.Material"];
	var	Target = _Result.Materials;
    for ( var i=0; i < Source.length; i++ )
	{
		var SourceMat = Source[i];

		var	ShadID = 0;
		if ( SourceMat.id == 45 || SourceMat.id == 46 )
			ShadID = 1;	// Stained glasses

		var	Obj =
		{
			ID : i,
			Name : SourceMat.properties.name,
			ShaderID : ShadID,
			Uniforms :
			[
				{ Name : "_TexDiffuse", Value : -1 },
				{ Name : "_TexNormal", Value : -1 },
			]
		}
		Target[i] = Obj;

		// Retrieve actual texture IDs
		Obj.Uniforms[0].Value = _TextureMap.Sampler2Index[SourceMat.params.diffuseSampler.value.ref];
		if ( Obj.Uniforms[0].Value == -1 )
			throw "Failed to retrieve diffuse texture for that material !";

		if ( SourceMat.params.normalSampler )
			Obj.Uniforms[1].Value = _TextureMap.Sampler2Index[SourceMat.params.normalSampler.value.ref];
		else
			Obj.Uniforms[1].Value = DummyNormalID;
		if ( Obj.Uniforms[1].Value == -1 )
			throw "Failed to retrieve normal texture for that material !";

		OriginalIDs.Index2ID[i] = SourceMat.id;
		OriginalIDs.ID2Index[SourceMat.id] = i;
	}

	return OriginalIDs;
}

// We don't give a fuck about samplers anymore, we just need to retrieve the texture ID !
// function ConvertSamplers( _ROOT, _TextureMap )
// {
// 	var	SamplerID2TextureID = {};
// 
// 	var	Source = _ROOT["o3d.Sampler"];
//     for ( var i=0; i < Source.length; i++ )
// 	{
// 		var SourceSampler = Source[i];
// 
// 		var	SamplerID = SourceSampler.id;
// 		var	TextureID = SourceSampler.params["o3d.texture"].value.ref;
// 		SamplerID2TextureID[SamplerID] = TextureID;
// 	}
// 
// 	// Add the default normal texture
// 	SamplerID2TextureID[-1] = _TextureMap.ID2Index[-1];
// 
// 	return SamplerID2TextureID;
// }

function ConvertTextures( _Result, _ROOT )
{
	_Result.Textures = [];

	var	OriginalIDs = {
		Index2ID : [],
		ID2Index : {},
		Sampler2Index : {}
	};

	var	Source = _ROOT["Patapom.DelayLoadedTexture"];
	var	Target = _Result.Textures;

	// Build original samplers' references that will be later replaced by Patapom textures' references
	var	Samplers = _ROOT["o3d.Sampler"];
	for ( var SamplerIndex=0; SamplerIndex < Samplers.length; SamplerIndex++ )
		OriginalIDs.Sampler2Index[Samplers[SamplerIndex].id] = Samplers[SamplerIndex].params["o3d.texture"].value.ref;

	// Add the default diffuse & normal textures
	var	TargetID = 0;
	Target[TargetID] =
	{
		ID : TargetID,
		Name : "DummyDiffuse",
		URL : "Textures/DummyDiffuse.png",
		WrapMode : "REPEAT",
		FilteringMode : "LINEAR_MIP_LINEAR",
		SynchronousLoad : true,	// We need them ASAP !
	};
	OriginalIDs.Sampler2Index[-1] = TargetID++;

	Target[TargetID] =
	{
		ID : TargetID,
		Name : "DummyNormal",
		URL : "Textures/DummyNormal.png",
		WrapMode : "REPEAT",
		FilteringMode : "LINEAR_MIP_LINEAR",
		SynchronousLoad : true,	// We need them ASAP !
	};
	OriginalIDs.Sampler2Index[-2] = TargetID++;

	// Add everything else
    for ( var i=0; i < Source.length; i++ )
	{
		var SourceTex = Source[i];

		var	URL = SourceTex.properties.TextureURI;
			URL = URL.replace( ".dds", ".png" );
			URL = URL.replace( ".tga", ".png" );

		var	TempID = URL.indexOf( "_N" ) != -1 || URL.indexOf( "Normal" ) != -1 ? 1 : 0;

		Target[TargetID] =
		{
			ID : TargetID,
			Name : SourceTex.properties.name,
			URL : "Textures/" + URL,
			WrapMode : "REPEAT",
			FilteringMode : "LINEAR_MIP_LINEAR",
			WaitTexID : TempID,	// Set a fallback texture while loading
		};
		OriginalIDs.Index2ID[TargetID] = SourceTex.id;
		OriginalIDs.ID2Index[SourceTex.id] = TargetID;
		for ( var SamplerIndex=0; SamplerIndex < SourceTex.properties.ReferencerSamplers.length; SamplerIndex++ )
			OriginalIDs.Sampler2Index[SourceTex.properties.ReferencerSamplers[SamplerIndex].ref] = TargetID;
		TargetID++;
	}

	return OriginalIDs;
}
</script>
</head>
<body onload="Init()">

<h1>Convert O3D JSON format into PATAPI format !</h1>
<br />
<br />
<div id="ResultJSON"></div>

</body>
</html>
